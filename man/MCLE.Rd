% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MCLE.R
\name{MCLE}
\alias{MCLE}
\title{Maximum Constrained Likelihood Estimator}
\usage{
MCLE(data, dist, initial, returnOptim = FALSE,
  constraintFunc = constraintET, constraintFuncDeriv = constraintDerivET)
}
\arguments{
\item{data}{A matrix of data.  If univariate, data should have 1 column.  If
multivariate, data should have one column for each dimension.}

\item{dist}{A distribution object (essentially a list with functions 
defining the distribution, but see the distribution class defined in this 
package).  See getNormalDistribution and the functions it loads for 
examples of how to define this distribution object and the corresponding 
functions.}

\item{initial}{Initial estimate for the parameters.  This should be a list 
of parameters such that it could be passed to the paramList2Vec function 
in the distribution object.}

\item{returnOptim}{Logical.  If FALSE (default) the function returns the 
numeric estimates of the parameters, converted back into a list object. If
TRUE, the function returns a list with the results of the call to optim 
(named "optim" in the output) as well as the parameters (named "solution")}

\item{constraintFunc}{A function taking a numeric vector of likelihood 
values and returning the adjusted likelihood values.}

\item{constraintFuncDeriv}{A function providing the derivative of the
constraint function.  This function should also accept a numeric vector
and return a numeric vector of derivative values.}
}
\value{
See the returnOptim argument description.
}
\description{
This function computes a "Maximum Constrained Likelihood Estimator" by using
optim() to optimize a constrained log-likelihood function.  The constraint 
is a function that is applied to the log-likelihood of each observation 
which, in the ideal case, prevents the log-likelihood from being too small 
and hence the observation too influential on the estimator.
}
\examples{
\dontrun{
data = matrix(rnorm(200), nrow = 100)
mst = list(dev = MCLE:::devMST, grad = MCLE:::gradDevMST,
           paramList2Vec = MCLE:::paramList2VecMST,
           paramVec2List = MCLE:::paramVec2ListMST)
initial = list(xi = c(0, 0), Omega = diag(c(1, 1)),
               alpha = c(0, 0), nu = 100)
MCLE(data, dist = mst, initial)

mt = list(dev = MCLE:::devMT, grad = MCLE:::gradDevMT,
          paramList2Vec = MCLE:::paramList2VecMT,
          paramVec2List = MCLE:::paramVec2ListMT)
initial = list(xi = c(0, 0), Omega = diag(c(1, 1)), nu = 100)
MCLE(data, dist = mt, initial)

msn = list(dev = MCLE:::devMSN, grad = MCLE:::gradDevMSN,
          paramList2Vec = MCLE:::paramList2VecMSN,
          paramVec2List = MCLE:::paramVec2ListMSN)
initial = list(xi = c(0, 0), Omega = diag(c(1, 1)), alpha = c(0, 0))
MCLE(data, dist = msn, initial)

mn = list(dev = MCLE:::devMN, grad = MCLE:::gradDevMN,
          paramList2Vec = MCLE:::paramList2VecMN,
          paramVec2List = MCLE:::paramVec2ListMN)
initial = list(xi = c(0, 0), Omega = diag(c(1, 1)), alpha = c(0, 0))
MCLE(data, dist = msn, initial)

data = rpois(30, lambda = 4.7)
data = c(data, 100)
dist = list(dev = MCLE:::devPsn, grad = MCLE:::gradDevPsn,
           paramList2Vec = MCLE:::paramList2VecPsn,
           paramVec2List = MCLE:::paramVec2ListPsn)
initial = list(lambda = 1)
MCLE(data, dist = dist, initial)
mean(data)
}

}

